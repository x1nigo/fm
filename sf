#!/usr/bin/env bash

# sf: A terminal file-manager written in bash
# Created by Chris IÃ±igo <https://github.com/x1nigo>

# Setup the terminal
setup_terminal() {
	# Clear screen and hide cursor
	printf '\e[?25l\e[2J\e[1;r'

	# Hide user input
	stty -echo
}

# Reset terminal
reset_terminal()  {
	# Clear screen and show cursor
	printf '\e[?25h\e[2J\e[1;r'

	# Show user input
	stty echo
}

# Prints the current directory
status_line() {
	# Print at the bottom of the terminal
	printf "\e[%sH\e[1m(%d/%d) %s\033[K\e[m" \
		"$((LINES-1))" \
		"$scroll" \
		"$list_total"\
		"$PWD"
	# Set the window name
	printf '\e]2;sf -:- %s\e'\\ "$PWD"
}

command_line() {
	printf '\e[%sH\e[?25h%s' "$((LINES))" "$1"
	stty echo
}

redraw() {
	read_dir
	clear
	print_dir
	status_line
}

# List the contents of your current working directory
read_dir() {
	# Array variables to display directories first
	local dirs
	local files

	# Add specific files in certain arrays
	for item in *; do
		if [[ -d "$item" ]]; then
			dirs+=("$item")
		else
			files+=("$item")
		fi
	done

	# Compile all files to be displayed (in order)
	list=("${dirs[@]}" "${files[@]}")

	# Directory is empty
	[[ ${list[0]} == "*" ]] && list[0]=empty

	# Total number of files in array
	list_total="${#list[@]}"
}

print_dir() {
	# List item order
	order=1

	# Format directories first then files
	for item in "${list[@]}"; do
		# Directory
		if [[ -d "$item" ]]; then
			format='\e[1m'
			suffix='/'
		elif [[ -x "$item" ]]; then
			format='\e[3m'
			suffix=
		else
			format='\e[m' && suffix=
		fi

		# Determine the area of focus
		if [[ "$order" == "$scroll" ]]; then
			focus="$item"
			format='\e[1;30;41m'
		fi

		# Finally print the whole damn thing
		printf "${format}%s${suffix}\033[K\e[m\\n" \
			"$item"
		((order+=1))
	done
}

# Depends on the filetype
action() { [[ -d "$focus" ]] && { cd "$focus" && scroll=1 ; } || xdg-open "$focus" >/dev/null 2>&1 ; }

# Don't make an action if directory is empty
avoid() { [[ "$focus" != "empty" ]] ; }

# This is really just the delete function
delete() {
	command_line "Delete \"$focus\"? [y/N] "
	read -n 1 ans
	[[ "$ans" == "y" ]] && rm -rf "$focus"
}

# Rename your file [can also be used to move]
rename() {
	command_line "\"$focus\" Rename: "
	read ans
	[[ -z "$ans" ]] && continue
	mv "$focus" "$ans"
}

# Create a new file
create_file() {
	command_line "New file: "
	read ans
	[[ -z "$ans" ]] && continue
	touch "$ans"
}

# Create a directory
create_dir() {
	command_line "New directory: "
	read ans
	[[ -z "$ans" ]] && continue
	mkdir -p "$ans"
}

# Copy files
copy() {
	command_line "Copy \"$focus\" to: "
	read ans
	[[ -z "$ans" ]] && continue
	cp -vr "$focus" "$ans"
}

# Move files
move() {
	command_line "Move \"$focus\" to: "
	read ans
	[[ -z "$ans" ]] && continue
	mv "$focus" "$ans"
}

keybinds() {
	clear
# Main output
cat << EOF
Keybindings:

j	go down
k	go up
q	quit
l	interact
h	go to previous directory
~	go to home directory
D	delete
N	new file
M	new directory
R	rename
g	go to top
G	go to botttom
c	copy
m	move
.	show/hide hidden files
?	read this help page
EOF

	# Wait for user to press return
	printf "\\n%s" "Press \`enter\` to exit help page."
	read -r enter
}

keys() {
	# Allow arrow keys to work
	escape_char=$(printf "\u1b")
	if [[ $input == $escape_char ]]; then
		read -rsn 2 input
	fi

	case "${input}" in
		# Go down
		j|'[B')
			if [[ "$scroll" -lt "$list_total" ]]; then
				((scroll++))
				clear
				print_dir
				status_line
			fi
			;;
		# Go up
		k|'[A')
			if [[ "$scroll" -gt 1 ]]; then
				((scroll--))
				clear
				print_dir
				status_line
			fi
			;;
		# Quit
		q)
			reset_terminal && exit
			;;
		# Action
		l|\
		'[C'|\
		'[OC'|\
		'')
			avoid && action
			redraw
			;;
		# Go to previous directory
		h|\
		'[D'|\
		'[OD')
			cd ../ && scroll=1
			redraw
			;;
		# Go to home directory
		'~')
			cd && scroll=1
			redraw
			;;
		# Copy file(s)
		c)
			avoid && copy && scroll=1
			setup_terminal
			redraw
			;;
		# Move file(s)
		m)
			avoid && move && scroll=1
			setup_terminal
			redraw
			;;
		# Rename a file/directory
		R)
			avoid && rename
			setup_terminal
			redraw
			;;
		# Delete a file
		D)
			avoid && delete && scroll=1
			setup_terminal
			redraw
			;;
		# Create a file
		N)
			create_file
			setup_terminal
			redraw
			;;
		# Create a directory
		M)
			create_dir
			setup_terminal
			redraw
			;;
		# Go to top of list
		g)
			scroll=1
			clear
			print_dir
			status_line
			;;
		# Go to bottom of list
		G)
			scroll="$list_total"
			clear
			print_dir
			status_line
			;;
		# Show hidden files
		.)
			shopt_flags=(u s)
			[[ $hidden == 0 ]] && hidden=1 || hidden=0
			shopt -"${shopt_flags[$hidden]}" dotglob
			scroll=1
			redraw
			;;
		?)
			keybinds && {
				clear
				print_dir
				status_line
			}
			;;
	esac
}

# The main function that runs every time
main() {
	hidden=0
	scroll=1
	setup_terminal
	redraw
	while :; do
		read -srn 1 input && keys
	done
}

main
